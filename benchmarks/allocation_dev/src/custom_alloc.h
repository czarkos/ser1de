#ifndef CUSTOM_ALLOC_H
#define CUSTOM_ALLOC_H

#include <google/protobuf/message.h>
#include <google/protobuf/message.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/reflection.h>
#include <iostream>
#include <cstring>
#include <vector>

#include"person.pb.h"
#include"proto_init.h"

void allocate_with_sizes_hacky(M& m, std::vector<size_t>& sizes_for_scatter, std::string& dummy_str) {
    // allocate space for the strings
    //dummy_str = std::string("a", sizes_for_scatter[1]);
    // <------------ STRING SETTERS ------>
    string_generated_setters(m, dummy_str);
}

/*
// Custom helper class for string reservation in M message
class MStringReserver {
public:
  static void reserve_strings(M* msg, size_t size) {
    // Get direct access to the internal string storage
    if (msg->has_f5()) {
      msg->unsafe_arena_release_f5()->reserve(size);
    }
    if (msg->has_f6()) {
      M::M10* nested = msg->mutable_f6();
      if (nested->has_f5()) {
        nested->unsafe_arena_release_f5()->reserve(size);
      }
    }
  }
};
*/

void allocateStringField(google::protobuf::Message* message, size_t string_size) {
    const google::protobuf::Descriptor* descriptor = message->GetDescriptor();
    const google::protobuf::Reflection* reflection = message->GetReflection();

    for (int i = 0; i < descriptor->field_count(); ++i) {
        const google::protobuf::FieldDescriptor* field = descriptor->field(i);

        // Allocate strings with specified size
        if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
            // First set an empty string to initialize the field
            reflection->SetString(message, field, std::string());
            // Then get a pointer to it for modification
            const std::string& str_ref = reflection->GetString(*message, field);
            std::string* str = const_cast<std::string*>(&str_ref);
            str->reserve(string_size); // Pre-allocate the string buffer
            std::cout << "Reserved space for a string of size: " << string_size << std::endl;
        }
        // Recursively handle nested messages
        else if (field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE) {
            if (field->is_repeated()) {
                int field_size = reflection->FieldSize(*message, field);
                for (int j = 0; j < field_size; ++j) {
                    google::protobuf::Message* nested_msg = reflection->MutableRepeatedMessage(message, field, j);
                    allocateStringField(nested_msg, string_size);
                }
            } else {
                google::protobuf::Message* nested_msg = reflection->MutableMessage(message, field);
                allocateStringField(nested_msg, string_size);
            }
        }
    }
}


/*
// This would be generated by the modified protobuf compiler
class M_StringAllocator {
public:
  // Allocate space for all string fields at once
  static void reserve_all_strings(M* msg, size_t size) {
    // Direct allocation for f5 string field
    if (!msg->_internal_f5().empty()) {
      msg->_internal_mutable_f5()->reserve(size);
    }
    
    // Handle nested message M10's string field
    if (msg->has_f6()) {
      M::M10* nested = msg->mutable_f6();
      if (!nested->_internal_f5().empty()) {
        nested->_internal_mutable_f5()->reserve(size);
      }
    }
  }

  // For more control, allow allocating individual fields
  static void reserve_f5(M* msg, size_t size) {
    if (!msg->_internal_f5().empty()) {
      msg->_internal_mutable_f5()->reserve(size);
    }
  }

  static void reserve_f6_f5(M* msg, size_t size) {
    if (msg->has_f6() && !msg->f6()._internal_f5().empty()) {
      msg->mutable_f6()->_internal_mutable_f5()->reserve(size);
    }
  }
};

void allocate_with_sizes_hacky_2(M& m, std::vector<size_t>& sizes_for_scatter, std::string& dummy_str) {
  // Use the generated allocator
  M_StringAllocator::reserve_all_strings(&m, sizes_for_scatter[1]);
}
*/

/*
void AllocateFieldsWithSizes(google::protobuf::Message* message, const std::vector<size_t>& sizes) {
  const google::protobuf::Descriptor* descriptor = message->GetDescriptor();
  const google::protobuf::Reflection* reflection = message->GetReflection();
  
  size_t size_index = 0;
  
  for (int i = 0; i < descriptor->field_count(); i++) {
    const google::protobuf::FieldDescriptor* field = descriptor->field(i);
    
    if (size_index >= sizes.size()) break;
    
    switch (field->cpp_type()) {
      case google::protobuf::FieldDescriptor::CPPTYPE_STRING: {
        std::string* str = reflection->MutableString(message, field);
        str->reserve(sizes[size_index++]);
        break;
      }
      case google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE: {
        if (field->is_repeated()) {
          google::protobuf::RepeatedPtrField<google::protobuf::Message>* repeated_field =
              reflection->MutableRepeatedPtrField<google::protobuf::Message>(message, field);
          repeated_field->Reserve(sizes[size_index++]);
        } else {
          google::protobuf::Message* nested_message = reflection->MutableMessage(message, field);
          // Recursively allocate for nested message
          AllocateFieldsWithSizes(nested_message, std::vector<size_t>(sizes.begin() + size_index, sizes.end()));
          size_index += nested_message->GetDescriptor()->field_count();
        }
        break;
      }
      case google::protobuf::FieldDescriptor::CPPTYPE_INT32:
      case google::protobuf::FieldDescriptor::CPPTYPE_INT64:
      case google::protobuf::FieldDescriptor::CPPTYPE_UINT32:
      case google::protobuf::FieldDescriptor::CPPTYPE_UINT64:
      case google::protobuf::FieldDescriptor::CPPTYPE_DOUBLE:
      case google::protobuf::FieldDescriptor::CPPTYPE_FLOAT:
      case google::protobuf::FieldDescriptor::CPPTYPE_BOOL:
      case google::protobuf::FieldDescriptor::CPPTYPE_ENUM:
        if (field->is_repeated()) {
          google::protobuf::RepeatedField<int>* repeated_field =
              reflection->MutableRepeatedField<int>(message, field);
          repeated_field->Reserve(sizes[size_index++]);
        }
        break;
    }
  }
}
*/
/*
// Custom allocator for Protobuf messages using Arena
class ProtobufArenaAllocator {
public:
    explicit ProtobufArenaAllocator(google::protobuf::Arena* arena)
        : arena_(arena) {}

    void* Allocate(size_t size) {
        return arena_->AllocateAligned(size);
    }

private:
    google::protobuf::Arena* arena_;
};

// Structure to represent the buffer layout
struct DecodedMessageBuffer {
    uint32_t offset_list_size;
    std::vector<uint32_t> offsets;  // 0: Primitives, 1+: Strings/Nested Messages
    uint8_t* encoded_data;
};

// Function to deserialize a Protobuf message using the Arena allocator
void DeserializeProtobufMessage(
    google::protobuf::Message* message,
    DecodedMessageBuffer& buffer,
    google::protobuf::Arena* arena)
{
    uint8_t* encoded_data = buffer.encoded_data;
    const google::protobuf::Descriptor* descriptor = message->GetDescriptor();
    const google::protobuf::Reflection* reflection = message->GetReflection();

    // Create an Arena-backed allocator
    ProtobufArenaAllocator allocator(arena);

    // **1. Bulk copy all primitive fields at once**
    uint32_t primitive_offset = buffer.offsets[0];  // Single offset for all primitives
    std::memcpy(message, encoded_data + primitive_offset, descriptor->field_count() * sizeof(int32_t));

    // **2. Pre-allocate space for all strings**
    for (int i = 1; i < descriptor->field_count(); i++) {
        const google::protobuf::FieldDescriptor* field = descriptor->field(i);
        uint32_t field_offset = buffer.offsets[i];

        if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
            // Allocate space in Arena for the string
            char* str_mem = static_cast<char*>(allocator.Allocate(128));  // Example: fixed size
            std::strncpy(str_mem, reinterpret_cast<char*>(encoded_data + field_offset), 127);
            str_mem[127] = '\0';  // Ensure null termination
            reflection->SetString(message, field, str_mem);
        }
    }
}
*/
#endif